# -*- coding: utf-8 -*-
"""MOS_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CyKesJp2x14lKyrK7_EoASqe_eKpboRt
"""

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt

data = pd.read_csv("/content/MOS_Material_ Data.csv")
data.head()

data['E'] = [27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85]
data['Density'] = [500,520,550,400,650,660,670,680,690,686,682,678,674,670,666,662,658,654,647,640,633,626,619,612,605,598,591,584,577,570]
data['Yield Strength'] = [5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20]


"""### Given Data"""

Length = 20 #in meteres
width = 0.4
depth = 0.2
external_load = 20*(10**3) # newtons
n_material_sheet = 10

"""### Predefine variables"""

width_each_layer = 0.04
I = 0               # Second moment of inertia
selfD_weight = 0    # self distributed weight
F_A = 0             # Supporting force at A
F_B = 0             # Supporting force at B
x_motion = 0        # Position of external load
ref_material = 1   # taking modular ratio of other material with respect to 1
materials = [1,2,3,4,5,6,7,8,9,10] 
#ref_material = 27    #It store index of materials used for the beam construction
#materials = [27, 27, 27, 27, 27, 27, 27, 27, 27, 27]

def calculate_n(E1, E2):
    return E2/E1
def area(n, Ref_area):
    return n*Ref_area

def neutral_axis(avg_y, t_area):
    return avg_y/t_area
def Area_modularratio(materials):
    n_materials = []
    area_materials = []
    t_area = 0
    avg_a = 0
    y =0.02
    for i in materials:
        n = calculate_n(data['E'][ref_material], data['E'][i])
        a = area(n, 0.04*0.2)
        t_area = t_area + a
        avg_a = avg_a + y*a
        y += 0.04
        area_materials.append(a);
        n_materials.append(n);
    return avg_a, t_area, n_materials

avg_a, t_area, n_materials = Area_modularratio(materials)
n_axis = neutral_axis(avg_a, t_area)
print("Modular ratios : ",n_materials)
print("Netural axis :",n_axis)

def moment_of_inertia(N_axis, depth, width_each_layer, modular_ratio):
    I = 0
    y = width_each_layer/2
    i_c = (depth*((width_each_layer)**3))/12
    for n in modular_ratio:
        i = i_c + (depth*width_each_layer)*(N_axis-y)**2
        I = I + n*i
        y += width_each_layer
    return I

I = moment_of_inertia(n_axis, 0.2, 0.04, n_materials)
print("Moment of Inertia ",I)

masses = []
for i in materials:
    m = data['Density'][i]*(0.16)
    masses.append(m)
    s = (m*9.81)
    selfD_weight += s
selfD_weight = selfD_weight/20
print("Mass of each sheet :",masses)
print("Self Distributed weight :",selfD_weight,"Nm")

"""### Calculate F_A and F_B and then Bending moment at different position of external load"""

BM = []
y=0
for x in range(1,11):
    F_B = ((20*(10**3)*x) + selfD_weight*20*10)/20
    F_A = ((20*(10**3) + selfD_weight*20) - F_B)

    # In between section B and C
    V = F_B - (selfD_weight*y)
    # For Maximum BM, Shear force will be zero
    y = F_B/selfD_weight
    if (0<y<=x):
        BM_b = (F_B*y) - selfD_weight*(y**2)/2
    else:
        BM_b = (F_B*x) - selfD_weight*(x**2)/2

    # In between section C and A
    V = F_A - (selfD_weight*y)
    # For Maximum BM, Shear force will be zero
    y = F_A/selfD_weight
    if (0<y<=(Length - x)):
        BM_a = (F_B*y) - selfD_weight*(y**2)/2
    else:
        BM_a = (F_B*(Length - x)) - selfD_weight*((Length - x)**2)/2
    BM.append(max(BM_a, BM_b))
print(BM)

x = [i for i in range(1,11)]
y = BM
plt.plot(x,y)
plt.xlabel("Distance of external load from one support(m)")
plt.ylabel("Max_Bending moment(Nm)")
plt.show()

Max_BM = max(BM)
print("Maximum bending moment : ",Max_BM,"Nm")

"""## Bending Stress"""

def Sigma(modular_ratio, BM, y_upper, I):
    sigma = []
    y = 0
    for i in range(11):
        s = -modular_ratio*BM*(y_upper-y)/I
        sigma.append(s)
        y += 0.004
    return sigma
sigma_max = []

width = 0
for i in range(10):
    sigma = Sigma(n_materials[i], Max_BM, 0.2-width, I)
    sigma_max.append(max([abs(s) for s in sigma])/(10**6))
    x = np.arange(-6, 5, 1)
    y = [s/(10**6) for s in sigma]
    width += 0.04
    plt.plot(x,y, label='Layer{n}'.format(n=i+1))
    plt.ylabel("Bending Stress(Mpa)")
    plt.xlabel("Layer {num}".format(num =i+1))
    ax = plt.gca()
    ax.axes.xaxis.set_visible(False)
    plt.legend(loc = 'lower right')
    plt.show()
    print("\n\n")

sigma_max # Maximum Bending stress for each layer

"""## Shear Stress"""

V = []
y=0
for x in range(1,11):
    F_B = ((20*(10**3)*x) + selfD_weight*20*10)/20
    F_A = ((20*(10**3) + selfD_weight*20) - F_B)

    # In between section B and C
    V_b = F_B - (selfD_weight*y)
    # For Maximum Shear force y == x
    V_b = F_B - (selfD_weight*x)

    # In between section C and A
    V_a = F_A - (selfD_weight*y)
    # For Maximum BM, Shear force will be zero
    V_a = F_A - (selfD_weight*(Length - x))

    V.append(max(V_a, V_b))
print(V)

Max_V = max(V)
print(Max_V)

T_top = []
T_bottom = []
y = 0
distance_from_neutral_axis = n_axis - y
for i in range(10):                #for every 10 layers
    distance_from_neutral_axis = n_axis - y
    t = ((Max_V/I) * ((distance_from_neutral_axis**2)/2 + (y*distance_from_neutral_axis)))
    T_top.append("{:.2f}".format(t))
    y += 0.04
    distance_from_neutral_axis = n_axis - y
    t = (Max_V/(I) * ((distance_from_neutral_axis**2)/2 + (y*distance_from_neutral_axis)))
    T_bottom.append("{:.2f}".format(t))
print("Layers                   : ",["Layer1","Layer2","Layer3","Layer4","Layer5","Layer6","Layer7","Layer8","Layer9","Layer10",])
print("Top Shear stress : ",T_top)
print("Bottom Shear stress : ",T_bottom)

"""## Comparing"""

Y_strength = data['Yield Strength']
i = 0
for m in materials:
    if (Y_strength[m] > sigma_max[i]):
        print("Layer {num}  : Yes".format(num = i+1))
        # print(end=" ")
        # print("Yes")
    else:
        print("Layer {num}  : No".format(num = i+1))
        # print(end=" ")
        # print("No")
    i += 1